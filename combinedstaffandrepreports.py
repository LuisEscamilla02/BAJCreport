# -*- coding: utf-8 -*-
"""CombinedStaffandRepReports.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u1c0ZGy7dTu6ZvIOiiJlV8gJwv-Wpp9q
"""

# Combined Campus Rep and Staff Reporting System with DOCX Output
# !pip install gspread oauth2client pandas reportlab python-docx
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import io
import gspread
import re
import textwrap
import seaborn as sns
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_ALIGN_VERTICAL, WD_TABLE_ALIGNMENT
from docx.oxml.ns import qn
from docx.oxml import OxmlElement

# For Staff Reports
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build

# For Campus Rep Reports
from oauth2client.service_account import ServiceAccountCredentials

# Staff Reports - Likert scale options and colors
STAFF_LIKERT_OPTIONS = ["Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"]
STAFF_COLORS = {
    "Strongly Disagree": "#d7191c",  # Red
    "Disagree": "#fdae61",           # Intermediate orange
    "Neutral": "#ffff42",            # Yellow
    "Agree": "#a6d96a",              # Light green
    "Strongly Agree": "#1a9641"      # Green
}

# Campus Rep Reports - Fixed ordered Likert scale options
CAMPUS_REP_LIKERT_ORDER = ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"]

# Helper function for document styling
def set_cell_background(cell, hex_color):
    """Set the background color of a table cell in a Word document."""
    cell_props = cell._element.tcPr
    if cell_props is None:
        cell_props = OxmlElement('w:tcPr')
        cell._element.append(cell_props)

    cell_shading = OxmlElement('w:shd')
    cell_shading.set(qn('w:fill'), hex_color.replace('#', ''))
    cell_props.append(cell_shading)

# STAFF REPORT FUNCTIONS
def connect_to_google_sheets(credentials_file, spreadsheet_id):
    """Connect to Google Sheets API with service account credentials"""
    SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
    creds = Credentials.from_service_account_file(credentials_file, scopes=SCOPES)
    service = build('sheets', 'v4', credentials=creds)
    sheets = service.spreadsheets()
    return sheets

def get_sheet_names(sheets, spreadsheet_id):
    """Get all sheet names in the spreadsheet"""
    spreadsheet = sheets.get(spreadsheetId=spreadsheet_id).execute()
    sheet_names = [sheet['properties']['title'] for sheet in spreadsheet['sheets']]
    return sheet_names

def get_sheet_data(sheets, spreadsheet_id, sheet_name):
    """Retrieve data from specified sheet"""
    range_name = f"'{sheet_name}'!A1:AAA1000"  # Adjust range as needed
    result = sheets.values().get(
        spreadsheetId=spreadsheet_id,
        range=range_name
    ).execute()
    values = result.get('values', [])
    return values

def clean_column_names(df):
    """Clean column names by extracting staff name and skill category"""
    cleaned_columns = []
    for col in df.columns:
        if '[' in col and ']' in col:
            # Extract the staff name and skill category
            match = re.match(r"(.*?)\s*\[(.*?)\]", col)
            if match:
                staff_name = match.group(1).strip()
                skill = match.group(2).strip()
                cleaned_columns.append(f"{staff_name} - {skill}")
            else:
                cleaned_columns.append(col)
        else:
            cleaned_columns.append(col)
    df.columns = cleaned_columns
    return df

def calculate_likert_distribution(df, staff_name):
    """
    Calculate the percentage distribution of Likert responses for each skill metric
    for the given staff member.
    """
    # Get columns associated with this staff member (expecting headers like "Name - Skill")
    staff_columns = [col for col in df.columns if staff_name.lower() in col.lower()]

    distribution = {}

    # For each column (skill metric), count responses
    for col in staff_columns:
        # Extract skill metric name from the column header
        skill = col.split(" - ")[-1]
        counts = {option: 0 for option in STAFF_LIKERT_OPTIONS}
        for val in df[col]:
            if val in STAFF_LIKERT_OPTIONS:
                counts[val] += 1

        distribution[skill] = counts
    return distribution

def create_clustered_bar_chart_staff(distribution, staff_name):
    """
    Create a clustered bar chart for staff report and return as bytes for embedding in Word
    """
    skills = list(distribution.keys())
    n_skills = len(skills)
    n_options = len(STAFF_LIKERT_OPTIONS)

    # Create the figure and axis
    fig, ax = plt.subplots(figsize=(7, 4))

    # Positions for the clusters on the x-axis
    indices = np.arange(n_skills)
    bar_width = 0.15  # Slightly wider to accommodate fewer bars

    for i, option in enumerate(STAFF_LIKERT_OPTIONS):
        # Get count values for this option across all skills
        counts = [distribution[skill][option] for skill in skills]
        # Compute bar positions for this option within each cluster
        positions = indices + i * bar_width - (n_options/2)*bar_width + bar_width/2
        ax.bar(positions, counts, width=bar_width, color=STAFF_COLORS[option], label=option)

    ax.set_xlabel("Skill Metrics")
    ax.set_ylabel("Count")
    ax.set_title(f"{staff_name} - Likert Scale Response Distribution")
    ax.set_xticks(indices)
    wrapped_labels = [textwrap.fill(skill, width=13) for skill in skills]  # Adjust width as needed
    ax.set_xticklabels(wrapped_labels, rotation=0, ha='center', fontsize=8)
    ax.legend(loc='upper right', bbox_to_anchor=(1, 1), ncol=1)
    ax.grid(axis='y', linestyle='--', alpha=0.7)

    plt.tight_layout()

    # Save the chart as bytes to embed in Word
    img_bytes = io.BytesIO()
    plt.savefig(img_bytes, format='png', dpi=300)
    img_bytes.seek(0)
    plt.close(fig)

    return img_bytes

def generate_staff_report_docx(staff_name, df, output_folder="reports"):
    """
    Generate a Word (.docx) report for the given staff member
    """
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    output_file = os.path.join(output_folder, f"{staff_name.replace(' ', '_')}_Report.docx")

    distribution = calculate_likert_distribution(df, staff_name)

    doc = Document()
    title = doc.add_heading(f"Staff Report: {staff_name}", level=1)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER

    chart_bytes = create_clustered_bar_chart_staff(distribution, staff_name)
    doc.add_picture(chart_bytes, width=Inches(6.5))
    chart_caption = doc.add_paragraph("Figure 1: Likert Scale Response Distribution")
    chart_caption.alignment = WD_ALIGN_PARAGRAPH.CENTER
    chart_caption.style = 'Caption'

    doc.add_heading("Response Summary", level=2)
    table = doc.add_table(rows=len(distribution)+1, cols=len(STAFF_LIKERT_OPTIONS)+1)
    table.style = 'Table Grid'
    table.alignment = WD_TABLE_ALIGNMENT.CENTER

    # Header row
    header_cells = table.rows[0].cells
    header_cells[0].text = "Skill Category"
    for i, option in enumerate(STAFF_LIKERT_OPTIONS):
        header_cells[i+1].text = option
        set_cell_background(header_cells[i+1], "#DDDDDD")
    for cell in header_cells:
        for paragraph in cell.paragraphs:
            for run in paragraph.runs:
                run.bold = True

    # Data rows with raw counts
    for i, (skill, counts) in enumerate(distribution.items()):
        row_cells = table.rows[i+1].cells
        row_cells[0].text = skill
        for j, option in enumerate(STAFF_LIKERT_OPTIONS):
            row_cells[j+1].text = str(counts[option])
            row_cells[j+1].paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER

    doc.add_paragraph()
    doc.save(output_file)
    print(f"Generated DOCX report for {staff_name}: {output_file}")
    return output_file

def process_staff_evaluation_docx(credentials_file, spreadsheet_id, sheet_name, staff_name):
    sheets_api = connect_to_google_sheets(credentials_file, spreadsheet_id)
    data = get_sheet_data(sheets_api, spreadsheet_id, sheet_name)
    if not data:
        print(f"No data found in sheet '{sheet_name}'")
        return {}
    df = pd.DataFrame(data[1:], columns=data[0])
    df = clean_column_names(df)
    pdf_file = generate_staff_report_docx(staff_name, df)
    print(f"Generated report for {staff_name}: {pdf_file}")
    return {staff_name: pdf_file}

# CAMPUS REP REPORT FUNCTIONS
def list_sheet_names(creds_file, sheet_id):
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds = ServiceAccountCredentials.from_json_keyfile_name(creds_file, scope)
    client = gspread.authorize(creds)
    workbook = client.open_by_key(sheet_id)
    worksheets = workbook.worksheets()
    return [sheet.title for sheet in worksheets]

def get_data(creds_file, sheet_id, sheet_name):
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds = ServiceAccountCredentials.from_json_keyfile_name(creds_file, scope)
    client = gspread.authorize(creds)
    sheet = client.open_by_key(sheet_id).worksheet(sheet_name)
    data = sheet.get_all_records()
    return pd.DataFrame(data)

def generate_report(df, staff_member):
    df_staff = df[df["Name of Campus Representative"].str.lower() == staff_member.lower()]
    if df_staff.empty:
        return f"No data available for staff member: {staff_member}"

    likert_mapping = {
        "Strongly Agree": 5,
        "Agree": 4,
        "Neutral": 3,
        "Disagree": 2,
        "Strongly Disagree": 1
    }

    likert_columns = [
        "For each statement below, please select the option that best represents your opinion [My Campus Rep is accessible, respectful, and responsive to my needs for support.]",
        "For each statement below, please select the option that best represents your opinion [I have received regular, clear communication from my Campus Rep.]",
        "For each statement below, please select the option that best represents your opinion [Reflection sessions (during Saturday trainings, as well as on-campus) with my Campus Rep have been useful.]",
        "For each statement below, please select the option that best represents your opinion [I would have liked more time to reflect upon my JusticeCorps experiences with my peers.]",
        "For each statement below, please select the option that best represents your opinion [My Campus Rep has been a good resource.]"
    ]

    report = f"Report for {staff_member}:\n" + "="*50 + "\n"
    for col in likert_columns:
        responses = df_staff[col].dropna()
        total = len(responses)
        freq = responses.value_counts().to_dict()
        numeric_responses = responses.map(likert_mapping)
        avg_rating = numeric_responses.mean() if not numeric_responses.empty else None

        report += f"\nQuestion: {col}\n"
        if avg_rating is not None:
            report += f"  Average Rating: {avg_rating:.2f}\n"
        else:
            report += "  Average Rating: No responses\n"
        report += "  Response Distribution (percentage):\n"
        perc_dict = {option: (freq.get(option, 0) / total) * 100 for option in CAMPUS_REP_LIKERT_ORDER}
        for option in CAMPUS_REP_LIKERT_ORDER:
            report += f"    - {option}: {perc_dict[option]:.2f}%\n"

    comments = df_staff["Comments on Campus Representative Support"].dropna().tolist()
    report += "\nComments:\n"
    if comments:
        for comment in comments:
            report += f"  - {comment}\n"
    else:
        report += "  No comments available.\n"
    report += "\n" + "="*50 + "\n"
    return report

def generate_clustered_bar_graph_campus_rep(df_staff, likert_columns):
    """
    Generates a clustered bar graph showing percentage distributions for each Likert question.
    Returns image bytes for embedding in Word.
    """
    num_questions = len(likert_columns)
    summary_data = {option: [] for option in CAMPUS_REP_LIKERT_ORDER}
    question_labels = []

    for i, col in enumerate(likert_columns):
        responses = df_staff[col].dropna()
        total = len(responses)
        question_labels.append(f"Q{i+1}")
        freq = responses.value_counts().to_dict()
        for option in CAMPUS_REP_LIKERT_ORDER:
            percentage = (freq.get(option, 0) / total) * 100 if total > 0 else 0
            summary_data[option].append(percentage)

    x = np.arange(num_questions)
    width = 0.15
    fig, ax = plt.subplots(figsize=(6, 3))
    for idx, option in enumerate(CAMPUS_REP_LIKERT_ORDER):
        offsets = x + idx * width - (len(CAMPUS_REP_LIKERT_ORDER)/2.0 * width)
        ax.bar(offsets, summary_data[option], width, label=option)

    ax.set_xlabel("Questions", fontsize=9)
    ax.set_ylabel("Percentage", fontsize=9)
    ax.set_title("Likert Response Distribution per Metric", fontsize=10)
    ax.set_xticks(x)
    ax.set_xticklabels(question_labels, fontsize=8)
    ax.legend(fontsize=7)
    ax.tick_params(axis='y', labelsize=8)
    plt.tight_layout()

    img_bytes = io.BytesIO()
    plt.savefig(img_bytes, format='png', dpi=300)
    img_bytes.seek(0)
    plt.close(fig)

    return img_bytes

def generate_docx_report(df, staff_member, output_filename=None):
    """
    Generates a Word (.docx) report for the given campus rep,
    including a clustered bar graph, a summary table with numerical counts,
    and a comments section.
    """
    if output_filename is None:
        safe_name = "".join(c for c in staff_member if c.isalnum() or c in ['_']).strip()
        output_filename = f"campus_rep_report_{safe_name}.docx"

    df_staff = df[df["Name of Campus Representative"] == staff_member]
    if df_staff.empty:
        print(f"No data available for staff member: {staff_member}")
        return

    likert_columns = [
        "For each statement below, please select the option that best represents your opinion [My Campus Rep is accessible, respectful, and responsive to my needs for support.]",
        "For each statement below, please select the option that best represents your opinion [I have received regular, clear communication from my Campus Rep.]",
        "For each statement below, please select the option that best represents your opinion [Reflection sessions (during Saturday trainings, as well as on-campus) with my Campus Rep have been useful.]",
        "For each statement below, please select the option that best represents your opinion [I would have liked more time to reflect upon my JusticeCorps experiences with my peers.]",
        "For each statement below, please select the option that best represents your opinion [My Campus Rep has been a good resource.]"
    ]

    question_labels = [
        "Accessible & Responsive",
        "Clear Communication",
        "Useful Reflection Sessions",
        "More Peer Reflection Time",
        "Good Resource"
    ]

    doc = Document()
    title = doc.add_heading(f"Campus Rep Report: {staff_member}", level=1)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER

    chart_bytes = generate_clustered_bar_graph_campus_rep(df_staff, likert_columns)
    doc.add_picture(chart_bytes, width=Inches(6.5))
    caption = doc.add_paragraph("Figure 1: Likert Response Distribution per Question")
    caption.alignment = WD_ALIGN_PARAGRAPH.CENTER
    caption.style = 'Caption'

    # Updated heading to reflect numeric counts
    doc.add_heading("Summary Table (Response Counts per Question)", level=2)

    table = doc.add_table(rows=len(question_labels)+1, cols=len(CAMPUS_REP_LIKERT_ORDER)+1)
    table.style = 'Table Grid'
    table.alignment = WD_TABLE_ALIGNMENT.CENTER

    header_cells = table.rows[0].cells
    header_cells[0].text = "Question"
    for i, option in enumerate(CAMPUS_REP_LIKERT_ORDER):
        header_cells[i+1].text = option
        set_cell_background(header_cells[i+1], "#DDDDDD")
    for cell in header_cells:
        for paragraph in cell.paragraphs:
            for run in paragraph.runs:
                run.bold = True

    # Fill in counts instead of percentages
    for i, (col, label) in enumerate(zip(likert_columns, question_labels)):
        responses = df_staff[col].dropna()
        freq = responses.value_counts().to_dict()
        row_cells = table.rows[i+1].cells
        row_cells[0].text = f"Q{i+1}: {label}"
        for j, option in enumerate(CAMPUS_REP_LIKERT_ORDER):
            count = freq.get(option, 0)
            row_cells[j+1].text = str(count)
            row_cells[j+1].paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Comments section
    doc.add_heading("Comments", level=2)
    comments = df_staff["Comments on Campus Representative Support"].dropna().tolist()
    if comments:
        for comment in comments:
            doc.add_paragraph(comment, style='List Bullet')
    else:
        doc.add_paragraph("No comments available.")

    doc.save(output_filename)
    print(f"DOCX report saved as {output_filename}")
    return output_filename

def staff_reports_main():
    """Main function to drive the staff report generation process."""
    print("\n=== Staff Report Generator ===")
    credentials_file = input("Enter the path to your Google API credentials file: ")
    if not os.path.exists(credentials_file):
        print(f"Error: File '{credentials_file}' not found.")
        return

    spreadsheet_id = input("Enter the Google Spreadsheet ID: ")

    try:
        sheets_api = connect_to_google_sheets(credentials_file, spreadsheet_id)
        sheet_names = get_sheet_names(sheets_api, spreadsheet_id)
        if not sheet_names:
            print("No sheets found in the spreadsheet.")
            return

        print("\nAvailable sheets:")
        for i, name in enumerate(sheet_names, 1):
            print(f"{i}. {name}")

        while True:
            try:
                selection = int(input("\nSelect a sheet number: "))
                if 1 <= selection <= len(sheet_names):
                    selected_sheet = sheet_names[selection - 1]
                    break
                else:
                    print(f"Please enter a number between 1 and {len(sheet_names)}")
            except ValueError:
                print("Please enter a valid number")

        print(f"\nProcessing sheet: {selected_sheet}")
        staff_name = input("\nEnter staff name to process (or leave blank to exit): ").strip()
        if not staff_name:
            print("No staff name provided. Exiting.")
            return

        process_staff_evaluation_docx(credentials_file, spreadsheet_id, selected_sheet, staff_name)

    except Exception as e:
        print(f"An error occurred: {str(e)}")

def campus_rep_reports_main():
    """Main function to drive the campus rep report generation process."""
    print("\n=== Campus Rep Report Generator ===")
    creds_file = input("Enter the Google API credentials JSON file path: ").strip()
    sheet_id = input("Enter the Google Sheet ID: ").strip()

    sheet_names = list_sheet_names(creds_file, sheet_id)
    print("\nAvailable sheets:")
    for idx, name in enumerate(sheet_names):
        print(f"{idx + 1}: {name}")
    sheet_choice = int(input("Enter the number corresponding to the sheet to pull data from: "))
    sheet_name = sheet_names[sheet_choice - 1]

    print("\nFetching data from the Google Sheet...")
    df = get_data(creds_file, sheet_id, sheet_name)
    print("Data fetched successfully.\n")

    unique_staff = df["Name of Campus Representative"].dropna().unique().tolist()
    print("Available Staff Members:")
    for idx, staff in enumerate(unique_staff):
        print(f"{idx + 1}: {staff}")
    staff_choice = int(input("Enter the number corresponding to the staff member for the report: "))
    staff_member = unique_staff[staff_choice - 1]

    print("\nGenerating text report...\n")
    report = generate_report(df, staff_member)
    print(report)

    with open("campus_rep_report.txt", "w", encoding="utf-8") as f:
        f.write(report)
    print("Text report saved to campus_rep_report.txt")

    print("Generating DOCX report with clustered bar graph, summary table, and comments...\n")
    generate_docx_report(df, staff_member)

def main():
    """Combined main function that prompts for report type selection."""
    print("\n====================================")
    print("    Combined Reporting System")
    print("====================================")

    while True:
        report_type = input("\nWhich report would you like to generate?\n1. Campus Rep Report\n2. Staff Report\n\nEnter your choice (1 or 2): ")
        if report_type in ["1", "2"]:
            break
        else:
            print("Invalid selection. Please enter 1 for Campus Rep Report or 2 for Staff Report.")

    if report_type == "1":
        campus_rep_reports_main()
    else:
        staff_reports_main()

    print("\nReport generation complete.")

if __name__ == "__main__":
    main()
